# NUT-00: 표기, 활용, 용어 (Notation, Utilization, and Terminology)

`mandatory`

---

이 문서는 명세 전반에서 사용하는 표기와 모델을 서술하고 Cashu 프로토콜에 쓰이는 기본 암호학을 이해하기 위한 기초를 마련한다.

- 송신 사용자: `Alice`
- 수신 사용자: `Carol`
- 민트: `Bob`

# 블라인드 디피-헬만 키 교환(BDHKE)

## 변수

- `G` 타원곡선의 생성점(generator point)

### Bob(민트)

- `k` 민트의 개인키(각 금액별 1개)
- `K` `k`에 대응하는 공개키
- `C_` 블라인드 서명(대상: `B_`)

### Alice(사용자)

- `x` UTF-8 인코딩 난수 문자열(비밀 메시지), 곡선상의 점 `Y = hash_to_curve(x)`에 대응
- `r` 블라인딩 인자
- `B_` 블라인딩된 메시지
- `C` 언블라인드 서명

### `hash_to_curve(x: bytes) -> curve point Y`

메시지를 secp256k1 곡선의 공개키 점으로 결정적으로 매핑한다. 고유성 보장을 위해 도메인 분리자를 사용한다.

`Y = PublicKey('02' || SHA256(msg_hash || counter))` 여기서 `msg_hash`는 `SHA256(DOMAIN_SEPARATOR || x)`

- `Y` 파생된 공개키
- `DOMAIN_SEPARATOR` 상수 바이트 문자열 `b"Secp256k1_HashToCurve_Cashu_"`
- `x` 해시할 메시지
- `counter` 곡선 위 점이 나올 때까지 0부터 증가하는 uint32 카운터(리틀엔디언)

## 프로토콜

- 민트 `Bob`은 공개키 `K = kG`를 게시한다.
- `Alice`는 비밀 `x`를 고르고 `Y = hash_to_curve(x)`를 계산한다.
- `Alice`는 임의의 블라인딩 인자 `r`로 `B_ = Y + rG`를 계산해 `Bob`에게 보낸다(**블라인딩**).
- `Bob`은 블라인드 키 `C_ = kB_`를 `Alice`에게 보낸다(이 두 단계가 DH 교환)(**서명**).
- `Alice`는 `C_ - rK = kY + krG - krG = kY = C`로 언블라인드 키를 계산한다(**언블라인딩**).
- `Alice`는 `(x, C)` 쌍을 토큰으로 보관하고 `Carol`에게 전송할 수 있다.
- `Carol`은 `(x, C)`를 `Bob`에게 보내고, `Bob`은 `k*hash_to_curve(x) == C`인지 확인하여(**검증**) 유효하면 이를 사용된 토큰으로 처리하고 `x`를 사용된 비밀 목록에 추가한다.

## 0.1 - 모델

### `BlindedMessage`

암호화(“블라인드”)된 비밀과 금액을 `Alice`가 `Bob`에게 [토큰 민팅][04] 또는 [토큰 스왑][03]을 위해 보낸다. `BlindedMessage`는 _output_이라고도 한다.

```json
{
  "amount": int,
  "id": hex_str,
  "B_": hex_str
}
```

`amount`는 요청된 `BlindSignature`의 금액, `id`는 서명을 기대하는 키셋 ID, `B_`는 `Alice`가 생성한 블라인딩된 비밀 메시지다. `[BlindedMessage]` 배열은 `BlindedMessages`라고 부른다.

### `BlindSignature`

`BlindSignature`는 [민팅][04] 또는 [스왑][03] 이후 `Bob`이 `Alice`에게 보내는 값이다. _promise_라고도 부른다.

```json
{
  "amount": int,
  "id": hex_str,
  "C_": hex_str
}
```

`amount`는 블라인딩된 토큰의 금액, `id`는 토큰을 서명한 민트 키의 [키셋 ID][02], `C_`는 이전 단계에서 전송된 비밀 메시지 `B_`에 대한 블라인드 서명이다.

### `Proof`

`Proof`는 _input_이라고도 하며, `Alice`가 받은 `BlindSignature`로부터 생성한다. `[Proof]`의 배열은 `Proofs`라 한다. `Alice`는 `Proofs`를 [멜팅][05]을 위해 `Bob`에게 보낸다. [직렬화](#serialization-of-tokens)된 `Proofs`는 `Alice`에서 `Carol`로 전달될 수도 있다. 토큰을 받은 `Carol`은 이를 역직렬화하고 새 `Proofs`를 받기 위해 `Bob`에게 [스왑][03]을 요청한다.

```json
{
  "amount": int,
  "id": hex_str,
  "secret": str,
  "C": hex_str
}
```

`amount`는 해당 `Proof`의 금액, `secret`은 UTF-8 인코딩된 비밀 메시지(지문화를 막기 위해 32바이트 난수에서 만든 64자 hex 권장), `C`는 `secret`에 대한 언블라인드 서명(hex), `id`는 토큰을 서명한 민트 공개키의 [키셋 ID][02](hex)다.

## 0.2 - 프로토콜

### 오류

오류가 발생하면 민트는 HTTP 상태 코드 `400`과 함께 다음 데이터를 포함해 응답한다.

```json
{
  "detail": "oops",
  "code": 1337
}
```

여기서 `detail`은 오류 메시지, `code`는 오류 코드다. 오류 코드는 해당 API 엔드포인트 사용 문서에서 정의한다.

## 0.3 - 메서드

### 토큰 직렬화(Serialization of tokens)

토큰은 사용자 `Alice`와 `Carol` 사이 전송을 위해 직렬화할 수 있다. 직렬화된 토큰에는 Cashu 토큰 접두사, 버전 플래그, 토큰이 포함된다. 선택적으로 웹에서 클릭 가능하도록 URI 접두사를 붙일 수 있다.

토큰 직렬화 형식은 다음과 같다.

```sh
cashu[version][token]
```

`cashu`는 Cashu 토큰 접두사다. `[version]`은 토큰 형식 버전을 나타내는 단일 `base64_urlsafe` 문자다.

##### URI 태그

웹에서 Cashu 토큰을 클릭 가능하게 만들기 위해 `cashu:` URI 스킴을 사용한다. URI 태그가 붙은 직렬화 예시는 다음과 같다.

```sh
cashu:cashuAeyJwcm9vZn...
```

### V3 토큰

> _V3 토큰은 더 이상 권장되지 않는다. 더 공간 효율적인 V4 토큰 사용을 권장한다._

##### 버전

이 토큰 형식의 `[version]` 값은 `A`다.

##### 형식

V3 토큰은 base64 인코딩된 JSON 객체다. 여러 민트의 토큰을 지원한다. JSON은 `base64_urlsafe`로 직렬화한다(`/`→`_`, `+`→`-`). `base64_urlsafe` 문자열 끝의 패딩(`=`)은 생략 가능하며, 클라이언트는 두 경우 모두 디코드할 수 있어야 한다.

```sh
cashuA[base64_token_json]
```

`[base64_token_json]`은 `base64_urlsafe`로 직렬화된 토큰 JSON이다. 직렬화 전 공백은 제거해야 한다.

##### 토큰 포맷

역직렬화된 `base64_token_json`은 다음과 같다.

```json
{
  "token": [
    {
      "mint": str,
      "proofs": Proofs
    },
    ...
  ],
  "unit": str <optional>,
  "memo": str <optional>
}
```

`mint`는 민트 URL이며 끝의 슬래시(`/`)는 제거해야 한다. `Proofs`는 `Proof` 객체 배열이다. `unit`은 토큰 키셋의 통화 단위([Keysets][01] 참조), `memo`는 송신자가 남긴 선택적 메모다.

##### 예시

다음은 `base64_urlsafe` 직렬화 전 TokenV3 JSON이다.

```json
{
  "token": [
    {
      "mint": "https://8333.space:3338",
      "proofs": [
        {
          "amount": 2,
          "id": "009a1f293253e41e",
          "secret": "407915bc212be61a77e3e6d2aeb4c727980bda51cd06a6afc29e2861768a7837",
          "C": "02bc9097997d81afb2cc7346b5e4345a9346bd2a506eb7958598a72f0cf85163ea"
        },
        {
          "amount": 8,
          "id": "009a1f293253e41e",
          "secret": "fe15109314e61d7756b0f8ee0f23a624acaa3f4e042f61433c728c7057b931be",
          "C": "029e8e5050b890a7d6c0968db16bc1d5d5fa040ea1de284f6ec69d61299f671059"
        }
      ]
    }
  ],
  "unit": "sat",
  "memo": "Thank you."
}
```

직렬화하면 다음과 같다.

```
cashuAeyJ0b2tlbiI6W3sibWludCI6Imh0dHBzOi8vODMzMy5zcGFjZTozMzM4IiwicHJvb2ZzIjpbeyJhbW91bnQiOjIsImlkIjoiMDA5YTFmMjkzMjUzZTQxZSIsInNlY3JldCI6IjQwNzkxNWJjMjEyYmU2MWE3N2UzZTZkMmFlYjRjNzI3OTgwYmRhNTFjZDA2YTZhZmMyOWUyODYxNzY4YTc4MzciLCJDIjoiMDJiYzkwOTc5OTdkODFhZmIyY2M3MzQ2YjVlNDM0NWE5MzQ2YmQyYTUwNmViNzk1ODU5OGE3MmYwY2Y4NTE2M2VhIn0seyJhbW91bnQiOjgsImlkIjoiMDA5YTFmMjkzMjUzZTQxZSIsInNlY3JldCI6ImZlMTUxMDkzMTRlNjFkNzc1NmIwZjhlZTBmMjNhNjI0YWNhYTNmNGUwNDJmNjE0MzNjNzI4YzcwNTdiOTMxYmUiLCJDIjoiMDI5ZThlNTA1MGI4OTBhN2Q2YzA5NjhkYjE2YmMxZDVkNWZhMDQwZWExZGUyODRmNmVjNjlkNjEyOTlmNjcxMDU5In1dfV0sInVuaXQiOiJzYXQiLCJtZW1vIjoiVGhhbmsgeW91LiJ9
```

### V4 토큰

V4 토큰은 CBOR 이진 포맷을 사용해 공간 효율적으로 토큰을 직렬화한다. 모든 필드는 한 글자 키를 사용하고, hex 문자열은 바이너리로 인코딩한다. V4 토큰은 단일 민트의 proofs만 담을 수 있다.

##### 버전

이 토큰 형식의 `[version]` 값은 `B`다.

##### 형식

월렛은 토큰을 `base64_urlsafe` 형식으로 직렬화한다(`/`→`_`, `+`→`-`). 패딩(`=`)은 생략 가능하며 클라이언트는 두 경우 모두 디코드 가능해야 한다.

```sh
cashuB[base64_token_cbor]
```

##### 토큰 포맷

역직렬화된 `base64_token_cbor`는 TokenV4와 동일한 형태의 JSON이지만 더 짧은 키를 쓰고, hex 문자열 대신 이진 데이터(`bytes`)를 사용한다. TokenV3의 `Proofs`에 해당하는 값은 여기서 `p`로 축약되며 직렬화 형식이 다르다.

```json
{
  "m": str, // 민트 URL
  "u": str, // 단위
  "d": str <optional>, // 메모
  "t": [
    {
      "i": bytes, // 키셋 ID
      "p": [ // 이 키셋 ID에 속한 proofs
        {
          "a": int, // 금액
          "s": str, // 비밀
          "c": bytes, // 서명
          "d": { <optional> // DLEQ 증명
            "e": bytes,
            "s": bytes,
            "r": bytes
          },
          "w": str <optional> // witness
        },
        ...
      ]
    },
    ...
  ]
}
```

`m`은 민트 URL이다. 끝의 `/`는 제거해야 한다. `u`는 토큰 키셋의 통화 단위([Keysets][01] 참고), `d`는 송신자의 선택적 메모다.

`i`는 `p` 내 proofs의 키셋 ID이며, `p`는 `id` 필드가 없는 `Proof` 객체 배열이다. 각 proof에서 `id`를 추출해 한 단계 위에서 `i`로 그룹화한다.

`bytes` 타입 필드들은 원래 `Proof` 표현의 hex 문자열을 바이너리로 인코딩한 것이다.

##### 예시

CBOR 및 `base64_urlsafe` 직렬화 전 TokenV4 JSON의 예시는 원문을 참조하라. 직렬화 결과 예시는 다음과 같다.

```
cashuBo2F0gqJhaUgA_9SLj17PgGFwgaNhYQFhc3hAYWNjMTI0MzVlN2I4NDg0YzNjZjE4NTAxNDkyMThhZjkwZjcxNmE1MmJmNGE1ZWQzNDdlNDhlY2MxM2Y3NzM4OGFjWCECRFODGd5IXVW-07KaZCvuWHk3WrnnpiDhHki6SCQh88-iYWlIAK0mjE0fWCZhcIKjYWECYXN4QDEzMjNkM2Q0NzA3YTU4YWQyZTIzYWRhNGU5ZjFmNDlmNWE1YjRhYzdiNzA4ZWIwZDYxZjczOGY0ODMwN2U4ZWVhY1ghAjRWqhENhLSsdHrr2Cw7AFrKUL9Ffr1XN6RBT6w659lNo2FhAWFzeEA1NmJjYmNiYjdjYzY0MDZiM2ZhNWQ1N2QyMTc0ZjRlZmY4YjQ0MDJiMTc2OTI2ZDNhNTdkM2MzZGNiYjU5ZDU3YWNYIQJzEpxXGeWZN5qXSmJjY8MzxWyvwObQGr5G1YCCgHicY2FtdWh0dHA6Ly9sb2NhbGhvc3Q6MzMzOGF1Y3NhdA
```

#### 바이너리 토큰(Binary Token)

적용 가능한 경우(NFC 전송 등) 토큰을 바이너리 형식으로 전송할 수 있다. 이때 직렬화된 토큰 앞에 접두사와 버전 바이트를 붙인다.

```
utf8("craw") || utf8(<token_version>) || <serialised_token>
```

- 바이너리 인코딩 V4: `utf8("craw") || utf8("B") || cbor(token_v4_object)`

[00]: 00.md
[01]: 01.md
[02]: 02.md
[03]: 03.md
[04]: 04.md
[05]: 05.md
[06]: 06.md
[07]: 07.md
[08]: 08.md
[09]: 09.md
[10]: 10.md
[11]: 11.md
[12]: 12.md
